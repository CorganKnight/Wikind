//* Type definitions:

Node : Type
Node.new (rank: U60) (root: U60) (children: (List Node)) : Node

BinomialHeap : Type
BinomialHeap = (List Node)
BinomialHeap.nil : BinomialHeap
BinomialHeap.nil = (List.nil  Node)
BinomialHeap.cons (x: Node) (xs: BinomialHeap) : BinomialHeap
BinomialHeap.cons x xs = (List.cons Node x xs)

//* Helper Functions

Pair.get <a: Type> <b: Type> <c: Type> (p: (Pair a b)) (fn: a -> b -> c) : c
Pair.get a1 b1 c1 (Pair.new a2 b2 fst snd) fn = (fn fst snd)

// Decreasing Range:
// Creates a range from n-1 to 0
DecRange (n: U60) : (List U60)
DecRange 0 = (List.nil U60)
DecRange n  =
    let dec = (- n 1)
    (List.cons U60 dec (DecRange dec))


//* "Getters"

Node.rank_copy (n: Node) : (Pair Node U60)
Node.rank_copy (Node.new rank root children) = (Pair.new rank (Node.new rank root children))

Node.children (n: Node) : BinomialHeap
Node.children (Node.new rank root children) = children

Node.rank_root (n: Node) : (Pair U60 U60)
Node.rank_root (Node.new rank root children) = (Pair.new rank root)

//* Heap Functions

// Links together two trees with the same rank
// The tree returned will be the tree with smaller root with:
//   - the other tree as one of its children
//   - its rank increased by 1
BinomialHeap.link (n1: Node) (n2: Node) : Node
BinomialHeap.link (Node.new r1 x1 c1) (Node.new r2 x2 c2) =
  (BinomialHeap.link.aux (> x2 x1) (Node.new r1 x1 c1) (Node.new r2 x2 c2))

  BinomialHeap.link.aux (bool: U60) (n1: Node) (n2: Node) : Node
  BinomialHeap.link.aux 1 (Node.new r1 x1 c1) n2 = (Node.new (+ r1 1) x1 (BinomialHeap.cons n2 c1))
  BinomialHeap.link.aux 0 n1 (Node.new r2 x2 c2) = (Node.new (+ r2 1) x2 (BinomialHeap.cons n1 c2))

// Inserts a Tree into the heap
// P.S.: Do not call it manually, you could break the heap structure
InsertTree (new: Node) (pq: BinomialHeap) : BinomialHeap
InsertTree (Node.new new_rank new_root new_child) (List.nil  Node) =
  (BinomialHeap.cons (Node.new new_rank new_root new_child) BinomialHeap.nil)
InsertTree (Node.new new_rank new_root new_child) (List.cons Node (Node.new x_rank x_root x_child) xs) =
  (InsertTree.aux
    (< new_rank x_rank)
    (Node.new new_rank new_root new_child)
    (BinomialHeap.cons (Node.new x_rank x_root x_child) xs)
  )

  InsertTree.aux (bool: U60) (new: Node) (xs: BinomialHeap) : BinomialHeap
  InsertTree.aux 1 new  xs                   = (BinomialHeap.cons new xs)
  InsertTree.aux 0 new (List.cons Node x xs) = (InsertTree (BinomialHeap.link new x) xs)

// Inserts a key into the heap
// It does so by creating a Node with the key and calling InsertTree
BinomialHeap.insert (x: U60) (pq: BinomialHeap) : BinomialHeap
BinomialHeap.insert x pq = (InsertTree (Node.new 0 x BinomialHeap.nil) pq)

// Merge together two heaps
BinomialHeap.merge (pq1: BinomialHeap) (pq2: BinomialHeap) : BinomialHeap
BinomialHeap.merge pq (List.nil Node) = pq
BinomialHeap.merge (List.nil Node) pq = pq
BinomialHeap.merge (List.cons Node x xs) (List.cons Node y ys) =
  (Pair.get (Node.rank_copy x) (x_rank => x_copy =>
  (Pair.get (Node.rank_copy y) (y_rank => y_copy =>
  (BinomialHeap.merge.aux
    (U60.spaceship x_rank y_rank)
    (BinomialHeap.cons x_copy xs)
    (BinomialHeap.cons y_copy ys)
  )))))

BinomialHeap.merge.aux (c: Cmp) (xs: BinomialHeap) (ys: BinomialHeap): BinomialHeap
BinomialHeap.merge.aux Cmp.ltn (List.cons Node x xs) ys =
  (BinomialHeap.cons x (BinomialHeap.merge xs ys))
BinomialHeap.merge.aux Cmp.gtn xs (List.cons Node y ys) =
  (BinomialHeap.cons y (BinomialHeap.merge xs ys))
BinomialHeap.merge.aux Cmp.eql (List.cons Node x xs) (List.cons Node y ys) =
  (InsertTree (BinomialHeap.link x y) (BinomialHeap.merge xs ys))

// Finds the node which contains the minimal value of the heap
// Returns the rank and root (key) of the node
// Raises an error on a empty heap
BinomialHeap.findMinNode (pq: BinomialHeap) : (Pair U60 U60)
BinomialHeap.findMinNode (List.cons Node x xs) =
  (BinomialHeap.findMinNode.aux xs (Node.rank_root x))

BinomialHeap.findMinNode.aux (pq: BinomialHeap) (pair: (Pair U60 U60)) : (Pair U60 U60)
BinomialHeap.findMinNode.aux (List.nil  Node     ) min_pair = min_pair
BinomialHeap.findMinNode.aux (List.cons Node x xs) min_pair =
  (Pair.get (Node.rank_root x) (x_rank => x_root =>
  (BinomialHeap.findMinNode.aux2 (< x_root (Pair.fst min_pair)) xs min_pair (Pair.new x_rank x_root))))

BinomialHeap.findMinNode.aux2 (b: U60) (xs: BinomialHeap) (min: (Pair U60 U60)) (x: (Pair U60 U60)) : (Pair U60 U60)
BinomialHeap.findMinNode.aux2 1 xs min_pair x_pair = (BinomialHeap.findMinNode.aux xs   x_pair)
BinomialHeap.findMinNode.aux2 0 xs min_pair x_pair = (BinomialHeap.findMinNode.aux xs min_pair)

// Finds the minimal element of the heap
// Returns Maybe.none if the heap is empty
BinomialHeap.findMin (pq: BinomialHeap) : (Maybe U60)
BinomialHeap.findMin (List.nil Node) = (Maybe.none U60)
BinomialHeap.findMin xs =
    let min_node_root = (Pair.snd (BinomialHeap.findMinNode xs))
    (Maybe.some min_node_root)

// Removes the minimal element of the heap
// Returns an empty heap if the heap is already empty
BinomialHeap.deleteMin (pq: BinomialHeap) : BinomialHeap
BinomialHeap.deleteMin (List.nil Node) = BinomialHeap.nil
BinomialHeap.deleteMin pq =
    let rank_to_remove = (Pair.fst (BinomialHeap.findMinNode pq))
    let get_min        = (BinomialHeap.removeRank pq rank_to_remove)
    (Pair.get get_min (removed => new_pq =>
    (BinomialHeap.merge (List.reverse (Node.children removed)) new_pq)))

// Finds the node with a specific rank
// Returns that node and the heap without it
BinomialHeap.removeRank (pq: BinomialHeap) (rank: U60) : (Pair Node BinomialHeap)
BinomialHeap.removeRank (List.cons Node (Node.new x_rank x_root x_child) xs) rank =
  (BinomialHeap.removeRank.aux
    (== x_rank rank)
    (BinomialHeap.cons (Node.new x_rank x_root x_child) xs)
    rank
  )

BinomialHeap.removeRank.aux (b: U60) (pq: BinomialHeap) (rank: U60) : (Pair Node BinomialHeap)
BinomialHeap.removeRank.aux 1 (List.cons Node x xs) rank = (Pair.new x xs)
BinomialHeap.removeRank.aux 0 (List.cons Node x xs) rank =
  let rec = (BinomialHeap.removeRank xs rank)
  (Pair.get rec (node => pq =>
  (Pair.new node (BinomialHeap.cons x pq))))

// Creates a heap using a list of natural numbers
BinomialHeap.fromList (xs: (List U60)) : BinomialHeap
BinomialHeap.fromList (List.nil  t     ) = BinomialHeap.nil
BinomialHeap.fromList (List.cons t x xs) = (BinomialHeap.insert x (BinomialHeap.fromList xs))

Main : _
Main = (
  // Some vars
  let heap1 = BinomialHeap.fromList [1 2 3 4 5]
  let heap2 = BinomialHeap.fromList [6 7 8 9 10 11 12]
  let heap3 = BinomialHeap.fromList [0 13 14 15 16 17]
  let heapmaster = (BinomialHeap.merge heap3 (BinomialHeap.merge heap1 heap2))

  // Testing Constructors/Functions
  // heapmaster
  // (BinomialHeap.findMin heapmaster)
  (BinomialHeap.deleteMin heapmaster)

  // "Benchmarking"
  // (BinomialHeap.fromList (DecRange      10)) //      236 RW
  // (BinomialHeap.fromList (DecRange     100)) //     2727 RW
  // (BinomialHeap.fromList (DecRange    1000)) //    27870 RW
  // (BinomialHeap.fromList (DecRange   10000)) //   279864 RW
  // (BinomialHeap.fromList (DecRange  100000)) //  2799835 RW
  // (BinomialHeap.fromList (DecRange 1000000)) // 27999806 RW
)
