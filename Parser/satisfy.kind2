// Succeeds if the head character satisfies a condition.
// This is implemented as the only code-taking primitive of the library.
// All other functions that consume characters are based on `satisfy`
Parser.satisfy (cond: Char -> Bool) : Parser Char {
  state =>
    match Parser.State state {
      new =>
        match String state.left {
          nil =>
            let state = Parser.State.new String.nil state.back state.index
            let error = Parser.Error.new "Unexpected EOF" state.index state.index
            Parser.Result.fail state error
          cons =>
            let left   = state.left.tail
            let back   = String.cons state.left.head state.back
            let index  = (+ 1 state.index)
            let state  = Parser.State.new left back index
            // Check condition
            if (cond state.left.head) {
              let result = state.left.head
              Parser.Result.done state result
            } else {
              let error = Parser.Error.new "" state.index index
              Parser.Result.fail state error
            }
        }
    }
}
