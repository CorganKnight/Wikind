// Succeeds if the head character satisfies a condition.
// This is implemented as the only code-taking primitive of the library.
// All other functions that consume characters are based on `satisfy`
Parser.satisfy (cond: Char -> Bool) : Parser Char {
  state =>
    match Parser.State state {
      new =>
        match String state.left {
          nil =>
            let new_state = Parser.State.new String.nil state.back state.index
            let error = Parser.Error.new "Unexpected EOF" state.index state.index
            Parser.Result.fail new_state error
          cons =>
            let head = state.left.head
            let old_state = Parser.State.new (String.cons state.left.head state.left.tail) state.back state.index
            let new_state = Parser.State.forward 1 old_state
            let index     = (+ 1 state.index)
            // Check condition
            if (cond head) {
              let result = head
              Parser.Result.done new_state result
            } else {
              let error = Parser.Error.new "" state.index index
              Parser.Result.fail new_state error
            }
        }
    }
}