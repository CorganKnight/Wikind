// U120 operations based on U60 numbers.
// - hi is the most significant 60 bits
// - lo is the least significant 60 bits

// U120 addition
U120.add (a: U120) (b: U120) : U120
U120.add (U120.new a.hi a.lo) (U120.new b.hi b.lo) =
  let c.lo = (+ a.lo b.lo)
  let c.hi = (+ a.hi b.hi)
  let over = (Bool.or (U60.less_than c.lo a.lo) (U60.less_than c.lo b.lo))
  let c.hi = if over { (+ c.hi 1) } else { c.hi }
  U120.new c.hi c.lo
  
// U120 subtraction
U120.sub (a: U120) (b: U120) : U120
U120.sub (U120.new a.hi a.lo) (U120.new b.hi b.lo) =
  let c.lo = (- a.lo b.lo)
  let c.hi = (- a.hi b.hi)
  let over = (U60.greater_than c.lo a.lo)
  let c.hi = if over { (- c.hi 1) } else { c.hi }
  U120.new c.hi c.lo

Main {
  U120.sub (U120.new 2 1000) (U120.new 0 1001) 
}

// U120 multiplication
//U120.mul (a: U120) (b: U120) : U120
//U120.mul (U120.new a.hi a.lo) (U120.newb




//uint32_t add_overflows(uint32_t a, uint32_t b) {
  //uint32_t sum = a + b;
  //return (sum < a) || (sum < b);
//}

// Returns 1 if the subtraction will overflow. That is,
// if (a -{

